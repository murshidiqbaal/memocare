import 'dart:io';

import 'package:dartz/dartz.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:uuid/uuid.dart';

import '../../core/errors/failures.dart';
import '../../models/user/caregiver_profile.dart';

final caregiverProfileRepositoryProvider =
    Provider<CaregiverProfileRepository>((ref) {
  return CaregiverProfileRepository(Supabase.instance.client);
});

class CaregiverProfileRepository {
  final SupabaseClient _supabase;

  CaregiverProfileRepository(this._supabase);

  Future<Either<Failure, CaregiverProfile>> getProfile(String userId) async {
    try {
      // 1. Try fetching from Supabase
      // Assuming 'caregiver_profiles' table has a 'user_id' column linking to auth.users.id
      // OR 'id' is the primary key and matches auth.uid()
      // Based on typical Supabase setup:
      final response = await _supabase
          .from('caregiver_profiles')
          .select()
          .eq('user_id', userId)
          .maybeSingle();

      if (response == null) {
        // Profile does not exist, return failure or perhaps a specific "NotFound" failure
        // The prompt says: "If profile does NOT exist: Show empty create-profile form"
        // So we can return a specific failure that the UI handles, or null.
        // Let's return a specific failure for "NotFound".
        return Left(const ServerFailure('Profile not found'));
      }

      final profile = CaregiverProfile.fromJson(response);

      // TODO: Save to Hive for offline cache here (omitted for brevity, can happen in ViewModel or separate service)

      return Right(profile);
    } catch (e) {
      // TODO: Try fetching from Hive if offline
      return Left(ServerFailure(e.toString()));
    }
  }

  Future<Either<Failure, CaregiverProfile>> createProfile(
      CaregiverProfile profile) async {
    try {
      final data = profile.toJson();
      // Remove 'id' if it's generated by DB, but typically ID is UUID.
      // If we are creating, we might not have an ID yet, or we generate one.
      // The model requires an ID.

      final response = await _supabase
          .from('caregiver_profiles')
          .insert(data)
          .select()
          .single();

      return Right(CaregiverProfile.fromJson(response));
    } catch (e) {
      return Left(ServerFailure(e.toString()));
    }
  }

  Future<Either<Failure, CaregiverProfile>> updateProfile(
      CaregiverProfile profile) async {
    try {
      final response = await _supabase
          .from('caregiver_profiles')
          .update(profile.toJson())
          .eq('id', profile.id)
          .select()
          .single();

      return Right(CaregiverProfile.fromJson(response));
    } catch (e) {
      return Left(ServerFailure(e.toString()));
    }
  }

  Future<Either<Failure, String>> uploadProfileImage(
      File imageFile, String userId) async {
    try {
      final fileExt = imageFile.path.split('.').last;
      final fileName =
          '$userId.${DateTime.now().millisecondsSinceEpoch}.$fileExt';
      final filePath = 'profile-photos/$fileName';

      await _supabase.storage
          .from('profile-photos')
          .upload(filePath, imageFile);

      final imageUrl =
          _supabase.storage.from('profile-photos').getPublicUrl(filePath);
      return Right(imageUrl);
    } catch (e) {
      return Left(ServerFailure(e.toString()));
    }
  }

  // Method to handle "Upsert" logic if needed, or check existence
  Future<bool> profileExists(String userId) async {
    try {
      final response = await _supabase
          .from('caregiver_profiles')
          .select('id')
          .eq('user_id', userId)
          .maybeSingle();
      return response != null;
    } catch (e) {
      return false;
    }
  }
}
